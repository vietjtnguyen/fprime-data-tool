#!/usr/bin/env python3
import enum
import io
import struct


# Global collection of all F Prime types keyed by their name.  We start with
# framework level types such as fundamental numeric types and ComPacket.  If a
# dictionary is loaded the types defined there in will be added to this
# collection.
fptypes = {}

# Class decorator factory for extending an enum.IntEnum based class with an
# decode class function and encode method based on the provided underlying
# type.
def enum_represented_as(enum_underlying_type):
    def decorator(type):
        def decode(cls, istream):
            untyped = enum_underlying_type.decode(istream)
            return cls(untyped.value)
        type.decode = classmethod(decode)

        def encode(self, ostream):
            untyped = enum_underlying_type(self.value)
            untyped.encode(ostream)
        type.encode = encode

        return type

    return decorator


#### Fundamental types ---------------------------------------------------------


# Creates a class representing the fundamental type given the name and struct
# format.
def make_fundamental_type(name, struct_format):
    fundamental_struct = struct.Struct(struct_format)

    class FundamentalType():

        def __init__(self, value = 0):
            self.value = value

        @classmethod
        def decode(cls, istream):
            data = istream.read(fundamental_struct.size)
            return cls(fundamental_struct.unpack(data)[0])

        def encode(self, ostream):
            return ostream.write(fundamental_struct.pack(self.value))

        def __float__(self):
            return float(self.value)

        def __format__(self, spec):
            return format(self.value, spec)

        def __int__(self):
            return int(self.value)

        def __repr__(self):
            return repr(self.value)

        def __str__(self):
            return str(self.value)

    FundamentalType.__name__ = name

    return FundamentalType


# Specification for fundamental_types.  Instead of manually writing out the
# types we construct them from this specification which is a tuple of name and
# struct format.
fundamental_type_specs = (
    ('I8', '>b'),
    ('U8', '>B'),
    ('I16', '>h'),
    ('U16', '>H'),
    ('I32', '>i'),
    ('U32', '>I'),
    ('I64', '>q'),
    ('U64', '>Q'),
    ('F32', '>f'),
    ('F64', '>d'),
)
fptypes_fundamental = {}
for name, struct_format in fundamental_type_specs:
    # Create the fundamental type and register it in fptypes.
    fptypes[name] = make_fundamental_type(name, struct_format)
    # Also collect the fundamental_types into their own collection.
    fptypes_fundamental[name] = fptypes[name]
    # Also put the fundamental_types into the global namespace for convenience.
    globals()[name] = fptypes[name]


#### F Prime configuration -----------------------------------------------------


# These are F Prime configuration flags (preprocessor definitions) that affect
# the format of data to be encoded/decoded.
fprime_configurable_flags = (
    # This controls whether the Time type includes the time base.
    ('FW_USE_TIME_BASE', True),
    # This controls whether the Time type includes the time context.
    ('FW_USE_TIME_CONTEXT', True),
)
for name, value in fprime_configurable_flags:
    # Put these flags in the global namespace for convenience.
    globals()[name] = value


# Another part of F Prime configuration is defining what fundamental types
# represent various things.  The following are the default type definitions.
# We also use this list to allow users to override using command line
# arguments.
fprime_configurable_types = (
    ('FwTimeBaseStoreType', fptypes['U16']),
    ('FwTimeContextStoreType', fptypes['U8']),
    ('FwPacketDescriptorType', fptypes['U32']),
    ('FwOpcodeType', fptypes['U32']),
    ('FwChanIdType', fptypes['U32']),
    ('FwEventIdType', fptypes['U32']),
    ('FwPrmIdType', fptypes['U32']),
    ('FwTlmPacketizeIdType', fptypes['U16']),
    # This is not actually an F Prime configurable type definition.  Instead we
    # define it to allow the user to configure the type used to represent the
    # packet size in a record.  This is needed because ComLogger packets use
    # U16 while fprime-gds recv.bin logs use U32.
    ('RecordSize', fptypes['U16']),
)
for name, value in fprime_configurable_types:
    # Define these types aliases in fptypes so they can be retrieved by name.
    fptypes[name] = value
    # Also put the type alias into the global namespace for convenience.
    globals()[name] = value


#### Basic non-fundamental types -----------------------------------------------


class Buffer():

    def __init__(self, data=b''):
        self.data = data

    @classmethod
    def decode(cls, istream, length=None):
        self = cls()
        self.data = istream.read(length)
        return self

    def encode(self, ostream):
        assert(type(self.data) is bytes)
        ostream.write(self.data)

    def __bytes__(self):
        return bytes(self.data)

    def __len__(self):
        return len(self.data)

    def __repr__(self):
        return repr(self.data)

    def __str__(self):
        return str(self.data)


class Time():

    @classmethod
    def decode(cls, istream):
        self = cls()
        if FW_USE_TIME_BASE:
            self.base = FwTimeBaseStoreType.decode(istream)
        if FW_USE_TIME_CONTEXT:
            self.context = FwTimeContextStoreType.decode(istream)
        self.seconds = U32.decode(istream)
        self.microseconds = U32.decode(istream)
        return self

    def encode(self, ostream):
        if FW_USE_TIME_BASE:
            assert(type(self.base) is FwTimeBaseStoreType)
        if FW_USE_TIME_CONTEXT:
            assert(type(self.context) is FwTimeContextStoreType)
        assert(type(self.seconds) is U32)
        assert(type(self.microseconds) is U32)
        if FW_USE_TIME_BASE:
            self.base.encode(ostream)
        if FW_USE_TIME_CONTEXT:
            self.context.encode(ostream)
        self.seconds = U32.decode(ostream)
        self.microseconds = U32.decode(ostream)

    def __str__(self):
        return str(float(self.seconds) + float(self.microseconds) * 1e-6)


#### Message, record, and F Prime packet types ----------------------------------


class Record():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.offset = istream.tell()
        self.packet_size = RecordSize.decode(istream)

        # We slice off the input stream into a buffer and create a new input
        # stream backed by that buffer to pass to the Packet parser. We do this
        # because some parsers nested underneath the Packet parser will "read
        # the rest" but without the size context here. For example, the event
        # and telemetry packet parsers do this. We use the size context here to
        # limit the rest of the record so that "read the rest" behavior
        # underneath works as expected and doesn't read the rest of the input
        # stream.
        packet_buffer = istream.read(self.packet_size.value)
        self.packet = Packet.decode(io.BytesIO(packet_buffer))

        return self

    def encode(self, ostream):
        assert(type(self.packet_size) is RecordSize)
        # TODO (vnguyen): Be smart about automatically calculating this.
        self.packet_size.encode(ostream)
        self.packet.encode(ostream)


class Packet():

    @enum_represented_as(FwPacketDescriptorType)
    class Type(enum.IntEnum):
        COMMAND = 0
        TELEM = 1
        LOG = 2
        FILE = 3
        PACKETIZED_TLM = 4
        IDLE = 5
        UNKNOWN = 0xFF

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.type = type(self).Type.decode(istream)
        if self.type == type(self).Type.TELEM:
            self.payload = TelemPacket.decode(istream)
        elif self.type == type(self).Type.LOG:
            self.payload = EventPacket.decode(istream)
        elif self.type == type(self).Type.FILE:
            self.payload = FilePacket.decode(istream)
        else:
            self.payload = Buffer.decode(istream)
        return self

    def encode(self, ostream):
        assert(type(self.type) is type(self).Type)
        if self.type == type(self).Type.TELEM:
            assert(type(self.payload) is TelemPacket)
        elif self.type == type(self).Type.LOG:
            assert(type(self.payload) is EventPacket)
        elif self.type == type(self).Type.FILE:
            assert(type(self.payload) is FilePacket)
        else:
            assert(type(self.payload) is Buffer)
        self.type.encode(ostream)
        self.payload.encode(ostream)


class TelemPacket():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.id = FwChanIdType.decode(istream)
        self.time = Time.decode(istream)
        self.value = Buffer.decode(istream)
        return self

    def encode(self, ostream):
        assert(type(self.id) == FwChanIdType)
        assert(type(self.time) == Time)
        assert(type(self.value) == Buffer)
        self.id.encode(ostream)
        self.time.encode(ostream)
        self.value.encode(ostream)


class EventPacket():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.id = FwEventIdType.decode(istream)
        self.time = Time.decode(istream)
        self.arguments = Buffer.decode(istream)
        return self

    def encode(self, ostream):
        assert(type(self.id) == FwEventIdType)
        assert(type(self.time) == Time)
        assert(type(self.arguments) == Buffer)
        self.id.encode(ostream)
        self.time.encode(ostream)
        self.arguments.encode(ostream)


class FilePacketPathName():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.length = U8.decode(istream)
        self.value = istream.read(self.length)
        return self

    def encode(self, ostream):
        assert(type(self.length) == U8)
        assert(type(self.value) == bytes)
        assert(len(self.value) == self.length)
        self.length.encode(ostream)
        ostream.write(self.value)

    def __str__(self):
        return self.value.encode('ascii')


class FilePacket():

    @enum_represented_as(U8)
    class Type(enum.IntEnum):
        START = 0
        DATA = 1
        END = 2
        CANCEL = 3
        NONE = 255

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.type = type(self).Type.decode(istream)
        self.sequence_index = U32.decode(istream)

        if self.type == type(self).Type.START:
            self.payload = FilePacketStartPayload.decode(istream)
        elif self.type == type(self).Type.DATA:
            self.payload = FilePacketDataPayload.decode(istream)
        elif self.type == type(self).Type.END:
            self.payload = FilePacketEndPayload.decode(istream)
        elif self.type == type(self).Type.CANCEL:
            self.payload = FilePacketCancelPayload.decode(istream)
        else:
            raise KeyError(f'Encountered unknown FilePacket type: {self.type}')

        return self

    def encode(self, ostream):
        assert(type(self.type) is type(self).Type)
        assert(type(self.sequence_index) is U32)
        assert(len(self.value) == self.length)
        if self.type == type(self).Type.START:
            assert(type(self.payload) is FilePacketStartPayload)
        elif self.type == type(self).Type.DATA:
            assert(type(self.payload) is FilePacketDataPayload)
        elif self.type == type(self).Type.END:
            assert(type(self.payload) is FilePacketEndPayload)
        elif self.type == type(self).Type.CANCEL:
            assert(type(self.payload) is FilePacketCancelPayload)
        else:
            raise KeyError(f'Encountered unknown FilePacket type: {self.type}')
        self.type.encode(ostream)
        self.sequence_index.encode(ostream)
        self.payload.encode(ostream)


class FilePacketStartPayload():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.file_size = U32.decode(istream)
        self.source_path = FilePacketPathName.decode(istream)
        self.destination_path = FilePacketPathName.decode(istream)
        return self

    def encode(self, ostream):
        self.file_size.encode(ostream)
        self.source_path.encode(ostream)
        self.destination_path.encode(ostream)


class FilePacketDataPayload():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.byte_offset = U32.decode(istream)
        self.data_size = U16.decode(istream)
        self.data = Buffer.decode(istream, self.data_size)
        return self

    def encode(self, ostream):
        assert(type(self.byte_offset) is U32)
        assert(type(self.data_size) is U16)
        assert(type(self.data) is Buffer)
        self.byte_offset.encode(ostream)
        self.data_size.encode(ostream)
        self.data.encode(ostream)


class FilePacketEndPayload():

    @classmethod
    def decode(cls, istream):
        self = cls()
        self.checksum = U32.decode(istream)
        return self

    def encode(self, ostream):
        assert(type(self.checksum) is U32)
        self.checksum.encode(ostream)


class FilePacketCancelPayload():

    @classmethod
    def decode(cls, istream):
        self = cls()
        return self

    def encode(self, ostream):
        pass


#### Dictionary ----------------------------------------------------------------


class FprimeDictionary():

    class Enum():

        class Item():

            def __init__(self, elem):
                self.name = elem.get('name')
                self.value_str = elem.get('value')
                self.value = int(self.value_str)
                self.description = elem.get('description')

            def __repr__(self):
                return f'("{self.name}", "{self.value_str}", "{self.description}")'

        def __init__(self, elem):
            self.name = elem.get('type')
            self.items = [type(self).Item(x) for x in elem.findall('item')]

        def decode(self, istream):
            pass

        def __repr__(self):
            return '{{"name": "{}", "items": [{}]}}'.format(
                self.name,
                ", ".join(str(x) for x in self.items))

    class Serializable():

        def decode(self, istream):
            pass

    class Array():

        def decode(self, istream):
            pass

    class Command():
        pass

    class Event():

        class Severity(enum.IntEnum):
            FATAL = 1
            WARNING_HI = 2
            WARNING_LO = 3
            COMMAND = 4
            ACTIVITY_HI = 5
            ACTIVITY_LO = 6
            DIAGNOSTIC = 7

        class Argument():

            def __init__(self, elem):
                self.name = elem.get('name')
                self.description = elem.get('description')
                self.length = int(elem.get('len')) if elem.get('len') else None
                self.type_str = elem.get('type')
                self.type = None

            def __repr__(self):
                return f'("{self.name}", "{self.description}", "{self.type_str}")'

        def __init__(self, elem):
            self.component = elem.get('component')
            self.name = elem.get('name')
            self.topology_name = f'{self.component}.{self.name}'
            self.id_str = elem.get('id')
            self.id = int(
                self.id_str,
                base=16 if self.id_str.startswith('0x') else 10)
            self.severity_str = elem.get('severity')
            self.severity = type(self).Severity[self.severity_str]
            self.description = elem.get('description')
            self.format_string = elem.get('format_string')
            self.args = [
                type(self).Argument(x)
                for x in elem.find('args').findall('arg')]

        def __repr__(self):
            return f'{{"component": "{self.component}", "name": "{self.name}", "id": "{self.id_str}"}}'

    class Channel():

        def __init__(self, elem):
            self.component = elem.get('component')
            self.name = elem.get('name')
            self.topology_name = f'{self.component}.{self.name}'
            self.id_str = elem.get('id')
            self.id = int(
                self.id_str,
                base=16 if self.id_str.startswith('0x') else 10)
            self.format_string = elem.get('format_string')
            self.description = elem.get('description')
            self.type_str = elem.get('type')
            self.type = None

        def __repr__(self):
            return f'{{"component": "{self.component}", "name": "{self.name}", "id": "{self.id_str}"}}'

    class Parameter():
        pass

    def __init__(self, file_path):
        self.enums = {}
        self.serializables = {}
        self.arrays = {}
        self.commands = {}
        self.events = {}
        self.events_by_id = {}
        self.channels = {}
        self.channels_by_id = {}
        self.parameters = {}
        self.types = {}

        from xml.etree import ElementTree
        tree = ElementTree.parse(file_path)
        root = tree.getroot()
        for collection in root:
            if collection.tag == 'enums':
                for elem in collection:
                    if elem.tag == 'enum':
                        enum = type(self).Enum(elem)
                        self.enums[enum.name] = enum
            elif collection.tag == 'serializables':
                for elem in collection:
                    if elem.tag == 'serializable':
                        pass
            elif collection.tag == 'arrays':
                for elem in collection:
                    if elem.tag == 'array':
                        pass
            elif collection.tag == 'commands':
                for elem in collection:
                    if elem.tag == 'command':
                        pass
            elif collection.tag == 'events':
                for elem in collection:
                    if elem.tag == 'event':
                        event = type(self).Event(elem)
                        self.events[(event.component, event.name)] = event
                        self.events_by_id[event.id] = event
            elif collection.tag == 'channels':
                for elem in collection:
                    if elem.tag == 'channel':
                        channel = type(self).Channel(elem)
                        self.channels[(channel.component, channel.name)] = channel
                        self.channels_by_id[channel.id] = channel
            elif collection.tag == 'parameters':
                for elem in collection:
                    if elem.tag == 'parameter':
                        pass


class TsvPrinter():

    def __init__(self, fprime_dictionary=None):
        self._d = fprime_dictionary

    def print_header(self):
        sys.stdout.write(
            'record_index'
            '\trecord_offset'
            '\tpacket_size'
            '\tpacket_type_name'
            '\tpacket_type_value'
            '\tpacket_time'
            '\ttelem_id'
            '\ttelem_id_hex'
            '\ttelem_topology_name'
            '\ttelem_component'
            '\ttelem_name'
            '\ttelem_time'
            '\ttelem_value_size'
            '\ttelem_value'
            '\tevent_id'
            '\tevent_id_hex'
            '\tevent_topology_name'
            '\tevent_component'
            '\tevent_name'
            '\tevent_severity'
            '\tevent_time'
            '\tevent_arguments_size'
            '\tevent_arguments'
            '\tpayload'
            '\n')

    def print_record(self, record):
        packet = record.packet
        payload = record.packet.payload
        sys.stdout.write(
            f'{record_index}'
            f'\t{record.offset}'
            f'\t{record.packet_size}'
            f'\t{packet.type.name}'
            f'\t{packet.type.value}')
        if record.packet.type == Packet.Type.TELEM:
            channel = self._d and self._d.channels_by_id.get(payload.id.value, None)
            sys.stdout.write(
                f'\t{payload.time}'
                f'\t{payload.id}'
                f'\t{payload.id:#x}'
                f'\t{getattr(channel, "topology_name", "")}'
                f'\t{getattr(channel, "component", "")}'
                f'\t{getattr(channel, "name", "")}'
                f'\t{payload.time}'
                f'\t{len(payload.value)}'
                f'\t{payload.value.data.hex() if len(payload.value) else ""}'
                '\t\t\t\t\t\t\t\t\t\t')
        elif record.packet.type == Packet.Type.LOG:
            event = self._d and self._d.events_by_id.get(payload.id.value, None)
            sys.stdout.write(
                f'\t{payload.time}'
                '\t\t\t\t\t\t\t\t'
                f'\t{payload.id}'
                f'\t{payload.id:#x}'
                f'\t{getattr(event, "topology_name", "")}'
                f'\t{getattr(event, "component", "")}'
                f'\t{getattr(event, "name", "")}'
                f'\t{getattr(event, "severity_str", "")}'
                f'\t{payload.time}'
                f'\t{len(payload.arguments)}'
                f'\t{payload.arguments.data.hex() if len(payload.arguments) else ""}'
                '\t')
        else:
            sys.stdout.write(
                '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'
                f'\t{payload.data.hex()}')
        sys.stdout.write('\n')

    def print_footer(self):
        pass


class VnlogPrinter():

    def __init__(self, fprime_dictionary=None):
        self._d = fprime_dictionary

    def print_header(self):
        sys.stdout.write(
            '#record_index'
            '\trecord_offset'
            '\tpacket_size'
            '\tpacket_type_name'
            '\tpacket_type_value'
            '\tpacket_time'
            '\ttelem_id'
            '\ttelem_id_hex'
            '\ttelem_topology_name'
            '\ttelem_component'
            '\ttelem_name'
            '\ttelem_time'
            '\ttelem_value_size'
            '\ttelem_value'
            '\tevent_id'
            '\tevent_id_hex'
            '\tevent_topology_name'
            '\tevent_component'
            '\tevent_name'
            '\tevent_severity'
            '\tevent_time'
            '\tevent_arguments_size'
            '\tevent_arguments'
            '\tpayload'
            '\n')

    def print_record(self, record):
        packet = record.packet
        payload = record.packet.payload
        sys.stdout.write(
            f'{record_index}'
            f'\t{record.offset}'
            f'\t{record.packet_size}'
            f'\t{packet.type.name}'
            f'\t{packet.type.value}')
        if record.packet.type == Packet.Type.TELEM:
            channel = self._d and self._d.channels_by_id.get(payload.id.value, None)
            sys.stdout.write(
                f'\t{payload.time}'
                f'\t{payload.id}'
                f'\t{payload.id:#x}'
                f'\t{getattr(channel, "topology_name", "-")}'
                f'\t{getattr(channel, "component", "-")}'
                f'\t{getattr(channel, "name", "-")}'
                f'\t{payload.time}'
                f'\t{len(payload.value)}'
                f'\t{payload.value.data.hex() if len(payload.value) else "-"}'
                '\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-')
        elif record.packet.type == Packet.Type.LOG:
            event = self._d and self._d.events_by_id.get(payload.id.value, None)
            sys.stdout.write(
                f'\t{payload.time}'
                '\t-\t-\t-\t-\t-\t-\t-\t-'
                f'\t{payload.id}'
                f'\t{payload.id:#x}'
                f'\t{getattr(event, "topology_name", "-")}'
                f'\t{getattr(event, "component", "-")}'
                f'\t{getattr(event, "name", "-")}'
                f'\t{getattr(event, "severity_str", "-")}'
                f'\t{payload.time}'
                f'\t{len(payload.arguments)}'
                f'\t{payload.arguments.data.hex() if len(payload.arguments) else "-"}'
                '\t-')
        else:
            sys.stdout.write(
                '\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-\t-'
                f'\t{payload.data.hex()}')
        sys.stdout.write('\n')

    def print_footer(self):
        pass


if __name__ == '__main__':
    import argparse
    import pathlib
    import sys

    parser = argparse.ArgumentParser(description='''
        fprime-data-tool is a command line utility to read F Prime data in
        different formats and configurations and display them in different
        formts. It can even work without a dictionary which is useful for
        sanity checking at the packet level. With an F Prime FSW dictionary
        specified it can interpret the data.''')

    parser.add_argument(
        'istream',
        nargs='?',
        type=argparse.FileType('rb'),
        default=sys.stdin.buffer,
        help='''
            input ComLogger file (default: read from stdin)''')
    parser.add_argument(
        '-F', '--output-format',
        action='store',
        type=str,
        choices=('tsv', 'vnlog'),
        default='vnlog',
        help=f'''
            selects the output format; default is \'vnlog\'''')
    parser.add_argument(
        '-d', '--dictionary',
        type=pathlib.Path,
        default=None,
        required=False,
        help='''
            path to F Prime dictionary used to interpret packet contents;
            default is to use no dictionary and display packet contents as
            binary blobs''')

    for name, default in fprime_configurable_flags:
        parser.add_argument(
            f'--{name}',
            metavar='BOOL',
            dest=name,
            action='store',
            type=bool,
            default=default,
            help=f'''
                sets the F Prime configuration for {name}; must
                be a Python truthy like 'True' or 'False'; default
                is \'{default}\'''')

    def FundamentalType(type_name):
        if type_name in fptypes_fundamental:
            return fptypes_fundamental[type_name]
        raise KeyError(f'Unknown fundamental_type name "{type_name}"')

    for name, default in fprime_configurable_types:
        parser.add_argument(
            f'--{name}',
            metavar='FUNDAMENTAL_TYPE',
            dest=name,
            action='store',
            type=FundamentalType,
            default=default,
            help='''
                sets the F Prime configuration for {}; must be one of the
                following fundamental_types: {}; default is \'{}\''''.format(
                    name,
                    ', '.join(
                        "'" + name + "'"
                        for name, _ in fundamental_type_specs),
                    default.__name__))

    args = parser.parse_args()

    for name, _ in fprime_configurable_flags:
        globals()[name] = getattr(args, name)

    for name, _ in fprime_configurable_types:
        globals()[name] = getattr(args, name)

    fprime_dictionary = args.dictionary and FprimeDictionary(args.dictionary)

    if args.output_format == 'tsv':
        printer = TsvPrinter(fprime_dictionary)
    elif args.output_format == 'vnlog':
        printer = VnlogPrinter(fprime_dictionary)
    else:
        raise KeyError(f'Unknown printer specified: "{args.output_format}"')

    printer.print_header()

    try:
        record_index = 0
        while True:
            record = Record.decode(args.istream)
            printer.print_record(record)
            record_index += 1
    except BrokenPipeError:
        pass

    printer.print_footer()
